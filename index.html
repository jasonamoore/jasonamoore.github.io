<html>

<head>

<title>Jason Moore</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">

<style>

body {
	margin: 0;
	font-family: Helvetica, sans-serif;
	color: #fff;
}

#page-wrap {
	width: 100%;
	height: 100%;
}

.half {
	position: relative;
	width: 100%;
	height: 50%;
	box-sizing: border-box;
}
#top-half {
	background-color: #171619;
}
#top-half > span {
	color: #f2f2ff;
	bottom: 25px;
}
#bottom-half {
	background-color: #f2f2ff;
}
#bottom-half > span {
	color: #171619;
	top: 25px;
}

.half > span {
	pointer-events: none;
	user-select: none;
	position: absolute;
	z-index: 10;
	margin-left: max(3%, 25px);
	font-size: max(36px, 5vw);
	font-weight: bold;
}

#top-half > canvas {
	position: absolute;
	bottom: 0px;
}

#right-bar {
	position: absolute;
	top: 50px;
	bottom: 50px;
	right: 0;
	width: 35%;
	min-width: 200px;
	padding: min(2.5%, 50px);
	padding-right: max(25px, 7%);
	/*background-color: rgba(255, 255, 255, 0.3);*/
	color: #f2f2ff;
	background-color: #171619;
	border-radius: 15px 0 0 15px;
}
/*
#top-half:hover ~ #right-bar {
	color: #f2f2ff;
	background-color: #171619;
}

#bottom-half:hover ~ #right-bar {
	color: #171619;
	background-color: #f2f2ff;
}
*/

#bar-content {
	height: 100%;
	box-sizing: border-box;
	padding: 10px;
	padding-right: 30px;
	overflow: auto;
}

.thumb:nth-of-type(1) {
	margin-top: 0;
}
.thumb {
	margin-top: 20px;
}

.thumb > img {
	width: 100%;
}

</style>

</head>

<body>

<div id="page-wrap">
	
	<div id="top-half" class="half"><span>Development</span><canvas id="dev-blot"></canvas></div>
	<div id="bottom-half" class="half"><span>Design</span><canvas id="dsn-blot"></canvas></div>
	
	<div id="right-bar">
		<div id="bar-content">
			<div class="thumb"><img src="placeholder.png" /><div class="desc">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></div>
			<div class="thumb"><img src="placeholder.png" /><div class="desc">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></div>
			<div class="thumb"><img src="placeholder.png" /><div class="desc">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></div>
		</div>
	</div>
	
</div>

<script>

// shorthand
function gbId(id) {
	return document.getElementById(id);
}

// useful objects to have
const tHalf = gbId("top-half");
const bHalf = gbId("bottom-half");

const devBlot = gbId("dev-blot");
const dsnBlot = gbId("dsn-blot");

const viz = {cellSize: undefined, nrows: undefined, ncols: undefined,
			 devGrid: undefined, dsnGrid: undefined};
/* 
  create state grids for each visualization (2d arrays)
  grid can only be as big as the max possible canvas size (based on screen size)
  divided by the size of a single grid cell, to get number of rows and columns
*/
function initVisuals() {
	// TODO: determine what grid size is appropriate?
	viz.cellSize = 12;
	viz.nrows = Math.ceil(window.screen.height / 2 / viz.cellSize);
	viz.ncols = Math.ceil(window.screen.width / viz.cellSize);
	// initialize state grids
	viz.devGrid = Array(viz.nrows).fill().map(() => Array(viz.ncols).fill(0));
	viz.dsnGrid = Array(viz.ncols).fill(null); // this one is 2d, just need columns
	// add listener for input interaction
	devBlot.addEventListener('mousemove', (event) => devHover(event));
	devBlot.addEventListener('mouseleave', () => {lastMouseX = undefined; lastMouseY = undefined;});
	// start looping update and render calls
	setInterval(() => {update(); renderDev();}, 100);
	setInterval(() => renderDesign(), 1000/60);
}

function update() {
	updateDevState();
	updateDesignState();
}

function updateDesignState() {
	// look for 1s at the bottom of dev grid
	for (let x = 0; x < viz.ncols; x++) {
		if (viz.devGrid[viz.nrows-1][x] == 1) {
			// make new paint drip here
			let oldDrip = viz.dsnGrid[x];
			// checking if we're ready to make a new drip here
			if (oldDrip === null || Date.now() - oldDrip.start >= oldDrip.duration) {
				viz.dsnGrid[x] = initNewDrip(x);
				viz.dsnGrid[x].prev = oldDrip;
			}
		}
	}
}

function initNewDrip(col) {
	function randColors() {
		let rgb = Array(3).fill(0).map(() => 210 + Math.random() * 45);
		let boosti = Math.floor(Math.random() * 3);
		rgb[boosti] = Math.min(255, rgb[boosti] + 30);
		let base = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
		rgb = rgb.map((col, i) => col - (i == boosti ? 25 : 55));
		let dark = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
		return [base, dark];
	}
	let [fcol, tcol] = randColors();
	return {from: fcol, to: tcol, col: col, // random colors, random speed, no height
			duration: 1000 * 2.5 * Math.random() + 3500, start: Date.now()};
}

function updateDevState() {
	// states for use while updating the board
	const stillDead = 0;
	const stillAlive = 1;
	const wasDead = 2; // used to denote a cell whose state will change
	const wasAlive = 3; // .. at the completion of this tick
	// helper to determine if this cell is/was alive
	function alive(row, col) {
		if (row < 0 || col < 0 || row >= viz.nrows || col >= viz.ncols) // OOB
			return false;
		else // is or was alive?
			return (viz.devGrid[row][col] == stillAlive || viz.devGrid[row][col] == wasAlive);
	}
	// helper to count live neighboring cells
	function countLiveNeighbors(row, col) {
		let count = 0;
		for (let i = -1; i <= 1; i++)
			for (let j = -1; j <= 1; j++)
				if (i == 0 && j == 0) // myself
					continue;
				else
					count += alive(row + i, col + j) ? 1 : 0;
		return count;
	}
	// Conway's Game of Life logic
	for (let y = 0; y < viz.nrows; y++) {
		for (let x = 0; x < viz.ncols; x++) {
			let buddies = countLiveNeighbors(y, x);
			let living = alive(y, x);
			/* Any live cell with fewer than two live neighbours dies, as if by underpopulation.
			   Any live cell with two or three live neighbours lives on to the next generation.
			   Any live cell with more than three live neighbours dies, as if by overpopulation.
			   Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction. */
			if (living && (buddies < 2 || buddies > 3))
				viz.devGrid[y][x] = wasAlive; // dies :(
			else if (!living && buddies == 3)
				viz.devGrid[y][x] = wasDead; // new life! :)
		}
	}
	// clean up wasDeads and wasAlives (convert to regular 0/1s)
	for (let y = 0; y < viz.nrows; y++) {
		for (let x = 0; x < viz.ncols; x++) {
			if (viz.devGrid[y][x] == wasAlive)
				viz.devGrid[y][x] = stillDead;
			else if (viz.devGrid[y][x] == wasDead)
				viz.devGrid[y][x] = stillAlive;
		}
	}
}

// trying mouse move ray tracing (point interpolation)
var lastMouseX = undefined;
var lastMouseY = undefined;

// called when cursor is moved over dev canvas
function devHover(event) {
	const mx = event.offsetX;
	const my = event.offsetY;
	const h = tHalf.getBoundingClientRect().height;
	// do steps between two mouse points
	if (lastMouseX !== undefined && lastMouseY !== undefined) {
		// determine how many steps to take
		let steps = Math.max(Math.abs(mx - lastMouseX) / viz.cellSize,
							 Math.abs(my - lastMouseY) / viz.cellSize);
		let curX = lastMouseX, curY = lastMouseY;
		let xstepAm = (mx - lastMouseX) / steps; // x amount to move per step
		let ystepAm = (my - lastMouseY) / steps; // y amount to move per step
		for (let s = 0; s < steps; s++) {
			// calculate interpol location in grid
			const gx = Math.floor(curX / viz.cellSize);
			const gy = Math.floor(viz.nrows - (h - curY) / viz.cellSize);
			curX += xstepAm;
			curY += ystepAm;
			if (gy < viz.nrows - 5) // don't set bottom rows
				viz.devGrid[gy][gx] = 2; // set to "wasDead"
		}
	}
	// no interpol; just get mouse's grid location
	const gx = Math.floor(mx / viz.cellSize);
	// (nrows - (h - my) / cellSize is to align at the half split)
	const gy = Math.floor(viz.nrows - (h - my) / viz.cellSize);
	// set to "wasDead" (to not interrupt any ongoing life-ing)
	if (gy < viz.nrows - 5) // only if not bottom few rows
		viz.devGrid[gy][gx] = 2;
	// update last mouse position
	lastMouseX = mx;
	lastMouseY = my;
}

/*
  draws on the canvases to make da magic happen
*/
function renderDev() {
	// determine canvas sizes, based on viewport size
	const w = tHalf.getBoundingClientRect().width;
	const h = tHalf.getBoundingClientRect().height;
	// update canvas element size to fit half-screen
	// this also clears the bitmap data before rendering
	devBlot.width = w;
	devBlot.height = h;
	// get canvas drawing context
	const devCtx = devBlot.getContext("2d");
	// set font for GOL display
	devCtx.font = viz.cellSize + "px monospace";
	devCtx.textBaseline = "top";
	const txtMetrics = devCtx.measureText("0");
	const txtOffW = (viz.cellSize - txtMetrics.width) / 2;
	const txtOffH = (viz.cellSize - Math.abs(txtMetrics.alphabeticBaseline)) / 2;
	function colorGrade(amt) {
		//	background-color: #171619;
		//  deadColor = "#383850";
		let newCol = 0x383850 - 0x07070A * (5 - amt)//Math.floor((0x383850 * amt + 0x171619 * (5 - amt)) / 5);
		return "#" + newCol.toString(16);
	}
	// draw from bottom so grid aligns at half
	for (let y = 0; y < viz.nrows; y++) {
		for (let x = 0; x < viz.ncols; x++) {
			// draw green 1 or grey 0 depending on cell state
			const cell = viz.devGrid[viz.nrows - y - 1][x];
			const cChar = y == 0 && cell ? "!" : cell; // special ! for bottom row
			const lifeColor = y == 0 ? "#952A75" : "#056532"; // special color for bottom row
			const deadColor = y > 5 ? "#383850" : colorGrade(y); // bottom rows get lighter
			devCtx.fillStyle = cell == 1 ? lifeColor : deadColor;
			devCtx.fillText(cChar, x * viz.cellSize + txtOffW,
							h - (y + 1) * viz.cellSize + txtOffH);
		}
	}
}

function renderDesign() {
	// determine canvas sizes, based on viewport size
	const w = bHalf.getBoundingClientRect().width;
	const h = bHalf.getBoundingClientRect().height;
	// update canvas element size to fit half-screen
	// this also clears the bitmap data before rendering
	dsnBlot.width = w;
	dsnBlot.height = h;
	// get canvas drawing context
	const dsnCtx = dsnBlot.getContext("2d");
	// design canvas drawin'
	// draw all prevs first (in background)
	for (let i = 0; i < viz.ncols; i++) {
		let drip = viz.dsnGrid[i];
		if (drip === null) // no drip here
			continue;
		// draw prev drip if exists
		if (drip.prev !== null) {
			const pgrad = dsnCtx.createLinearGradient(0, 0, 0, h);
			pgrad.addColorStop(0, drip.prev.from);
			pgrad.addColorStop(1, drip.prev.to);
			dsnCtx.fillStyle = pgrad;
			dsnCtx.fillRect(i * viz.cellSize, 0, viz.cellSize, h);
		}
	}
	// sort foreground drips on start time
	realDrips = viz.dsnGrid.filter(drip => drip !== null);
	realDrips.sort((a, b) => a.start - b.start);
	// for drawing drip circles
	const halfSize = viz.cellSize / 2;
	const pad = 10;
	for (let i = 0; i < realDrips.length; i++) {
		let drip = realDrips[i];
		// how much of the animation duration has passed, as a fraction
		const durfact = Math.min(1, (Date.now() - drip.start) / drip.duration);
		const yOff = halfSize + pad; // start drawing here so it comes in smooth from the top
		const height = (h + yOff) * durfact; // start before to fit bottom circle
		const rpad = pad * (1 - durfact);
		// draw circle at end of drip to make it round
		dsnCtx.fillStyle = drip.to;
		dsnCtx.beginPath();
		dsnCtx.arc(drip.col * viz.cellSize + halfSize, height - yOff, halfSize + rpad, 0, 2 * Math.PI);
		dsnCtx.fill();
		const grad = dsnCtx.createLinearGradient(0, 0, 0, height - yOff);
		grad.addColorStop(0, drip.from);
		grad.addColorStop(1, drip.to);
		dsnCtx.fillStyle = grad;
		dsnCtx.fillRect(-rpad + drip.col * viz.cellSize, -yOff, viz.cellSize + rpad * 2, height);
	}
}

initVisuals();

</script>

</body>

</html>